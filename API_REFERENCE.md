# DUNE RTS - API REFERENCE

## ðŸ“š **COMPLETE API DOCUMENTATION**

This document provides comprehensive documentation for all manager systems and their public APIs.

---

## ðŸª **ResourceManager**

### **Purpose**
Centralized resource management for all factions (spice, power, population).

### **Signals**
```gdscript
## Emitted when any resource amount changes
signal resource_changed(resource_type: String, amount: int, faction: GlobalEnums.Faction)

## Emitted when a spend operation fails
signal resource_insufficient(resource_type: String, required: int, available: int, faction: GlobalEnums.Faction)
```

### **Enums**
```gdscript
enum ResourceType {
    SPICE,      # Primary currency, collected from spice deposits
    POWER,      # Generated by power plants, consumed by buildings  
    POPULATION  # Unit capacity limit, increased by building houses
}
```

### **Public Methods**

#### `get_resource(faction: GlobalEnums.Faction, resource_type: ResourceType) -> int`
**Purpose:** Get current amount of a resource for a faction  
**Returns:** Resource amount, or 0 if not found  
**Example:**
```gdscript
var spice = resource_manager.get_resource(GlobalEnums.Faction.ATREIDES, ResourceManager.ResourceType.SPICE)
```

#### `add_resource(faction: GlobalEnums.Faction, resource_type: ResourceType, amount: int) -> bool`
**Purpose:** Add resources to faction's stockpile  
**Parameters:**
- `faction`: Target faction
- `resource_type`: Type of resource to add
- `amount`: Amount to add (must be positive)
**Returns:** true if successful, false if faction invalid  
**Side Effects:** Emits `resource_changed` signal  
**Example:**
```gdscript
# Harvester collected 25 spice
resource_manager.add_resource(GlobalEnums.Faction.ATREIDES, ResourceManager.ResourceType.SPICE, 25)
```

#### `spend_resource(faction: GlobalEnums.Faction, resource_type: ResourceType, amount: int) -> bool`
**Purpose:** Spend resources from faction's stockpile  
**Returns:** true if successful, false if insufficient resources  
**Side Effects:** Emits `resource_changed` on success, `resource_insufficient` on failure  
**Example:**
```gdscript
if resource_manager.spend_resource(GlobalEnums.Faction.ATREIDES, ResourceManager.ResourceType.SPICE, 400):
    print("Tank purchased!")
```

#### `can_afford(faction: GlobalEnums.Faction, costs: Dictionary) -> bool`
**Purpose:** Check if faction can afford multiple resource costs (read-only)  
**Parameters:**
- `costs`: Dictionary mapping ResourceType to required amounts
**Returns:** true if faction has enough of ALL resources  
**Example:**
```gdscript
var costs = {
    ResourceManager.ResourceType.SPICE: 400,
    ResourceManager.ResourceType.POWER: 2
}
if resource_manager.can_afford(GlobalEnums.Faction.ATREIDES, costs):
    print("Can build tank")
```

#### `spend_multiple(faction: GlobalEnums.Faction, costs: Dictionary) -> bool`
**Purpose:** Atomic transaction - spend multiple resource types  
**Returns:** true if ALL resources spent, false if any insufficient  
**Note:** Either ALL resources are spent or NONE (atomic operation)

---

## ðŸŽ¯ **SelectionManager**

### **Purpose**
Handle unit/building selection with multi-select and box selection support.

### **Signals**
```gdscript
signal selection_changed(selected_objects: Array)
signal unit_selected(unit)
signal unit_deselected(unit)
signal building_selected(building)
signal building_deselected(building)
```

### **Properties**
```gdscript
var player_faction: GlobalEnums.Faction  # Which faction the player controls
```

### **Public Methods**

#### `select_unit(unit: Unit, multi_select: bool = false) -> bool`
**Purpose:** Select a unit (if it belongs to player faction)  
**Parameters:**
- `multi_select`: If false, clears previous selections first
**Returns:** true if selection successful  
**Side Effects:** Updates unit visual state, emits signals

#### `select_units_in_rect(world_rect: Rect2, multi_select: bool = false) -> int`
**Purpose:** Box selection - select all player units in rectangle  
**Returns:** Number of units selected  
**Example:**
```gdscript
var rect = Rect2(Vector2(100, 100), Vector2(200, 200))
var count = selection_manager.select_units_in_rect(rect, true)
print("Selected %d units" % count)
```

#### `select_building(building: Building) -> bool`
**Purpose:** Select a building (clears unit selection)  
**Note:** Only one building can be selected at a time

#### `get_selection_info() -> Dictionary`
**Purpose:** Get detailed information about current selection  
**Returns:**
```gdscript
{
    "unit_count": int,           # Number of selected units
    "has_building": bool,        # Whether a building is selected
    "unit_types": Dictionary,    # Unit type -> count mapping
    "total_health": Dictionary   # Current/max health info
}
```

#### `clear_all_selections()`
**Purpose:** Deselect all units and buildings

---

## âš”ï¸ **CommandManager**

### **Purpose**
Command Pattern implementation - all game actions as encapsulated commands.

### **Signals**
```gdscript
signal command_executed(command_name: String, success: bool)
signal command_failed(command_name: String, reason: String)
```

### **Command Classes**

#### `MoveCommand`
```gdscript
var command = CommandManager.MoveCommand.new(units_array, target_position)
command_manager.execute_command(command)
```

#### `AttackCommand`
```gdscript
var command = CommandManager.AttackCommand.new(units_array, target_unit)
command_manager.execute_command(command)
```

#### `ProduceUnitCommand`
```gdscript
var command = CommandManager.ProduceUnitCommand.new(building, "tank")
command_manager.execute_command(command)
```

### **Convenience Methods**

#### `move_units(units: Array[Unit], target_position: Vector2) -> bool`
**Purpose:** Move multiple units to a position  
**Example:**
```gdscript
var units = selection_manager.get_selected_units()
command_manager.move_units(units, Vector2(500, 300))
```

#### `attack_with_units(units: Array[Unit], target: Unit) -> bool`
**Purpose:** Command units to attack a target

#### `stop_units(units: Array[Unit]) -> bool`
**Purpose:** Stop all unit actions (movement, combat)

---

## ðŸ­ **UnitFactory**

### **Purpose**
Data-driven unit creation from configuration files.

### **Public Methods**

#### `create_unit(unit_id: String, faction: GlobalEnums.Faction, position: Vector2) -> Unit`
**Purpose:** Create a unit from data configuration  
**Parameters:**
- `unit_id`: Unit type identifier (e.g., "tank", "infantry")
- `faction`: Which faction owns the unit
- `position`: World position to spawn at
**Returns:** Configured Unit instance or null if failed  
**Example:**
```gdscript
var tank = unit_factory.create_unit("tank", GlobalEnums.Faction.ATREIDES, Vector2(300, 300))
if tank:
    game_world.add_child(tank)
```

#### `get_unit_data(unit_id: String) -> UnitData`
**Purpose:** Get the raw configuration data for a unit type  
**Returns:** UnitData resource or null if not found

#### `can_build_unit(unit_id: String, faction: GlobalEnums.Faction) -> bool`
**Purpose:** Check if faction meets prerequisites to build unit  
**Checks:** Required buildings, tech tree, etc.

---

## ðŸ“Š **GameEvents (Event Bus)**

### **Purpose**
Global event system for loose coupling between systems.

### **Static Usage**
```gdscript
# Emit events from anywhere in the codebase
GameEvents.emit_unit_created(unit)
GameEvents.emit_resource_collected("spice", 25, faction)
GameEvents.emit_ui_notification("Tank completed!", "success")
```

### **Available Events**
```gdscript
# Unit events
unit_created(unit: Unit)
unit_destroyed(unit: Unit)
unit_damaged(unit: Unit, damage: int, attacker: Unit)

# Building events  
building_created(building: Building)
building_destroyed(building: Building)
building_completed(building: Building)

# Resource events
resource_collected(type: String, amount: int, faction: GlobalEnums.Faction)
resource_spent(type: String, amount: int, faction: GlobalEnums.Faction)

# Game events
game_victory(winner: GlobalEnums.Faction)
game_defeat(loser: GlobalEnums.Faction)

# UI events
ui_notification(message: String, type: String)
ui_alert(message: String, position: Vector2)
```

### **Connecting to Events**
```gdscript
func _ready():
    GameEvents.instance.unit_created.connect(_on_unit_created)
    GameEvents.instance.resource_collected.connect(_on_resource_collected)

func _on_unit_created(unit: Unit):
    print("New unit: %s" % unit.unit_name)
```

---

## ðŸŽ® **GameManager (Facade)**

### **Purpose**
Coordinates all systems and provides a unified API.

### **Key Responsibilities**
- Initialize and coordinate managers
- Provide facade API for common operations
- Handle game state transitions

### **Selection API**
```gdscript
# Delegates to SelectionManager
game_manager.select_unit(unit, multi_select)
game_manager.get_selected_units()
game_manager.select_building(building)
```

### **Command API**
```gdscript
# Delegates to CommandManager
game_manager.move_selected_units(position)
game_manager.attack_with_selected_units(target)
game_manager.stop_selected_units()
```

### **Resource API**
```gdscript
# Delegates to ResourceManager
game_manager.add_spice(amount, faction)
game_manager.spend_spice(amount, faction)
game_manager.get_player_spice()
```

### **Unit Creation API**
```gdscript
# Delegates to UnitFactory
var unit = game_manager.create_unit("tank", faction, position)
```

---

## ðŸ“‹ **Usage Patterns**

### **Common Workflows**

#### **Building a Unit**
```gdscript
# 1. Check if can afford
var costs = unit_factory.get_unit_data("tank").get_costs()
if resource_manager.can_afford(player_faction, costs):
    # 2. Spend resources
    if resource_manager.spend_multiple(player_faction, costs):
        # 3. Create unit
        var unit = unit_factory.create_unit("tank", player_faction, spawn_pos)
        # 4. Register with game
        game_manager.register_unit(unit)
```

#### **Implementing New Feature**
```gdscript
# 1. Listen to relevant events
GameEvents.instance.unit_created.connect(_on_unit_created)

# 2. React to events
func _on_unit_created(unit: Unit):
    if unit.unit_name == "Tank":
        GameEvents.emit_ui_notification("Tank ready for combat!", "info")
```

#### **Custom Command**
```gdscript
# 1. Extend Command class
class CustomCommand extends CommandManager.Command:
    func execute() -> bool:
        # Custom logic here
        return true

# 2. Execute through CommandManager
var command = CustomCommand.new()
command_manager.execute_command(command)
```

---

## ðŸ”§ **Configuration**

### **Unit Data Files**
Located in `data/units/*.tres`
```gdscript
# Example: tank.tres
unit_id = "tank"
unit_name = "Tank"
max_health = 150.0
attack_damage = 35.0
spice_cost = 400
# ... more properties
```

### **Game Config**
Located in `scripts/config/GameConfig.gd`
```gdscript
# Modify game balance
starting_resources = {
    ResourceManager.ResourceType.SPICE: 2000  # Give more starting spice
}
```

---

This API provides a solid foundation for extending the RTS with new features while maintaining clean separation of concerns and testability.