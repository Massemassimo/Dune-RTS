extends Node
class_name ResourceManager

## Resource Management System
##
## Single Responsibility: Handle all resource-related operations for all factions
## 
## This manager centralizes all resource operations (spice, power, population) and provides
## a clean API for spending, adding, and querying resources. It supports multiple factions
## and emits events for UI updates and game logic.
##
## Usage Example:
## [codeblock]
## var rm = ResourceManager.new()
## rm.add_resource(GlobalEnums.Faction.ATREIDES, ResourceManager.ResourceType.SPICE, 100)
## if rm.spend_resource(GlobalEnums.Faction.ATREIDES, ResourceManager.ResourceType.SPICE, 50):
##     print("Purchase successful")
## [/codeblock]

## Emitted when any resource amount changes for any faction
## @param resource_type: The type of resource that changed (SPICE, POWER, POPULATION)
## @param amount: The new total amount of the resource
## @param faction: Which faction's resources changed
signal resource_changed(resource_type: String, amount: int, faction: GlobalEnums.Faction)

## Emitted when a spend operation fails due to insufficient resources
## @param resource_type: The type of resource that was insufficient
## @param required: The amount that was requested
## @param available: The amount that was actually available
## @param faction: Which faction attempted the transaction
signal resource_insufficient(resource_type: String, required: int, available: int, faction: GlobalEnums.Faction)

## Internal storage: faction -> resource_type -> amount
## Structure: {GlobalEnums.Faction: {ResourceType: int}}
var faction_resources: Dictionary = {}

## Available resource types in the game
## These map to actual game resources that factions can collect and spend
enum ResourceType {
	SPICE,      ## Primary currency, collected from spice deposits
	POWER,      ## Generated by power plants, consumed by buildings
	POPULATION  ## Unit capacity limit, increased by building houses
}

## Starting amounts when a new faction is initialized
## Balanced for early game progression
const STARTING_RESOURCES = {
	ResourceType.SPICE: 1000,      ## Enough for initial units
	ResourceType.POWER: 100,       ## Enough for basic buildings
	ResourceType.POPULATION: 50    ## Reasonable unit cap
}

func _ready():
	initialize_factions()

## Initialize all factions with starting resources
## Called automatically when the node is ready
## Creates the faction_resources dictionary and emits initial resource_changed signals
func initialize_factions():
	for faction in GlobalEnums.Faction.values():
		faction_resources[faction] = {}
		for resource_type in ResourceType.values():
			faction_resources[faction][resource_type] = STARTING_RESOURCES[resource_type]
			resource_changed.emit(ResourceType.keys()[resource_type], faction_resources[faction][resource_type], faction)

## Get the current amount of a specific resource for a faction
## @param faction: The faction to query (e.g., GlobalEnums.Faction.ATREIDES)
## @param resource_type: The resource to query (e.g., ResourceType.SPICE)
## @return: The current amount of the resource, or 0 if faction/resource doesn't exist
##
## Example:
## [codeblock]
## var spice_amount = resource_manager.get_resource(GlobalEnums.Faction.ATREIDES, ResourceManager.ResourceType.SPICE)
## print("Player has %d spice" % spice_amount)
## [/codeblock]
func get_resource(faction: GlobalEnums.Faction, resource_type: ResourceType) -> int:
	if faction_resources.has(faction) and faction_resources[faction].has(resource_type):
		return faction_resources[faction][resource_type]
	return 0

## Add resources to a faction's stockpile
## @param faction: The faction to receive resources
## @param resource_type: The type of resource to add
## @param amount: The amount to add (must be positive)
## @return: true if successful, false if faction doesn't exist
##
## Emits resource_changed signal on success
##
## Example:
## [codeblock]
## # Harvester collected 25 spice
## resource_manager.add_resource(GlobalEnums.Faction.ATREIDES, ResourceManager.ResourceType.SPICE, 25)
## [/codeblock]
func add_resource(faction: GlobalEnums.Faction, resource_type: ResourceType, amount: int) -> bool:
	if not faction_resources.has(faction):
		return false
	
	if not faction_resources[faction].has(resource_type):
		faction_resources[faction][resource_type] = 0
	
	faction_resources[faction][resource_type] += amount
	resource_changed.emit(ResourceType.keys()[resource_type], faction_resources[faction][resource_type], faction)
	return true

## Attempt to spend resources from a faction's stockpile
## @param faction: The faction to spend from
## @param resource_type: The type of resource to spend
## @param amount: The amount to spend (must be positive)
## @return: true if successful, false if insufficient resources
##
## Emits resource_changed on success, resource_insufficient on failure
##
## Example:
## [codeblock]
## # Try to build a tank that costs 400 spice
## if resource_manager.spend_resource(GlobalEnums.Faction.ATREIDES, ResourceManager.ResourceType.SPICE, 400):
##     print("Tank purchased!")
## else:
##     print("Not enough spice")
## [/codeblock]
func spend_resource(faction: GlobalEnums.Faction, resource_type: ResourceType, amount: int) -> bool:
	var available = get_resource(faction, resource_type)
	
	if available >= amount:
		faction_resources[faction][resource_type] = available - amount
		resource_changed.emit(ResourceType.keys()[resource_type], faction_resources[faction][resource_type], faction)
		return true
	else:
		resource_insufficient.emit(ResourceType.keys()[resource_type], amount, available, faction)
		return false

## Check if a faction can afford multiple resource costs
## @param faction: The faction to check
## @param costs: Dictionary mapping ResourceType to required amounts
## @return: true if faction has enough of ALL resources, false otherwise
##
## This is a read-only operation that doesn't modify resources
##
## Example:
## [codeblock]
## var tank_costs = {
##     ResourceManager.ResourceType.SPICE: 400,
##     ResourceManager.ResourceType.POWER: 2,
##     ResourceManager.ResourceType.POPULATION: 3
## }
## if resource_manager.can_afford(GlobalEnums.Faction.ATREIDES, tank_costs):
##     print("Can build tank")
## [/codeblock]
func can_afford(faction: GlobalEnums.Faction, costs: Dictionary) -> bool:
	for resource_type in costs.keys():
		if get_resource(faction, resource_type) < costs[resource_type]:
			return false
	return true

## Spend multiple resource types in a single atomic transaction
## @param faction: The faction to spend from
## @param costs: Dictionary mapping ResourceType to amounts to spend
## @return: true if ALL resources were spent successfully, false if any insufficient
##
## This is atomic - either ALL resources are spent or NONE are spent
##
## Example:
## [codeblock]
## var tank_costs = {
##     ResourceManager.ResourceType.SPICE: 400,
##     ResourceManager.ResourceType.POWER: 2,
##     ResourceManager.ResourceType.POPULATION: 3
## }
## if resource_manager.spend_multiple(GlobalEnums.Faction.ATREIDES, tank_costs):
##     # Create the tank - all resources were successfully spent
##     create_tank()
## [/codeblock]
func spend_multiple(faction: GlobalEnums.Faction, costs: Dictionary) -> bool:
	if not can_afford(faction, costs):
		return false
	
	for resource_type in costs.keys():
		spend_resource(faction, resource_type, costs[resource_type])
	
	return true